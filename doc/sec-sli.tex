\section{Un langage impératif simple}
Pour commencer, définissons une syntaxe abstraite minimale que nous utiliserons tout le long de cette étude. 
Cette syntaxe se composera de trois blocs fondamentaux que sont les expressions arithmétiques, les expressions 
booléennes ainsi que les déclarations. Nous n'incluons pas pour le moment la déclaration de routines au sein de cette syntaxe.

\subsection{Expressions arithmétiques}
Les expressions arithmétiques sont définies sur l'ensemble des entiers relatifs. On se donne les opérateurs 
de l'addition, de la soustraction ainsi que de la multiplication. À ces opérateurs l'on pourra appliquer des 
entiers ainsi que des identifiants de variables.

% \begin{dtype}{Int}
%   \inlinekind{n}\with{n\in\mathbb{Z}}
% \end{dtype}
% \begin{dtype}{Id}
%   \inlinekind{x}
%   \kind{y}
%   \kind{z}
%   \kind{\ldots}
% \end{dtype}
% \begin{dtype}{Exp_a}
%   \inlinekind{Int}
%   \kind{Id}
%   \kind{op_A (a_1, a_2)}
%   \with{op_A \in\{+, -, \times\}}
% \end{dtype}

\begin{align*}
Int &\rightarrow n &n \in \mathbb{Z}\\
Id &\rightarrow x \mid y \mid z \mid \cdots \\
Exp_a &\rightarrow Int \mid Id \mid op_A(a_1, a_2) &op_A \in \{+, -, \times\}
\end{align*}
L'identifiant d'une variable est, de manière générale, une chaîne de caractères.

\subsection{Expressions booléennes}
Les expressions booléennes nous permettent d'introduire la comparaison entre deux expressions arithmétiques, 
ainsi que les opérateurs booléens sur les expressions booléennes.

\begin{dtype}{Exp_b}
  \inlinekind{\textbf{true}}
  \kind{\textbf{false}}\\
  \akind{op_R (a_1, a_2)}\with{op_R\in\{<, =\}}
  \akind{op_B (b_1, b_2)}\with{op_B\in\{\wedge, \vee\}}
  \akind{\neg{b}}
\end{dtype}

\subsection{Déclarations}
Les déclarations sont définies de la manière suivante:

\begin{dtype}{Stm}
  \inlinekind{\sassign{Id}{Exp_a}}\\
  \akind{\sseq{s_1}{s_2}}\\
  \akind{ }\\
  \akind{\sifthenelse{b}{s_1}{s_2}}\\
  \akind{\swhiledo{b}{s}}
\end{dtype}

\subsection{Exemple}
Voici un premier exemple sur ce langage
\begin{lstlisting}
a := 1;
b := 20;

if a = 3 then
	c := 4
else
	c := 6
endif;

while b < 100 do
	b := b + 1
done
\end{lstlisting}

\subsection{Arbre de syntaxe abstraite}
Ce modèle de représentation permet de construire un arbre de syntaxe abstraite (AST) du programme en question, 
cette structure étant un moyen pratique de le représenter. Cela nous servira particulièrement lors des différentes 
analyses qui seront effectuées, et notamment l'analyse par flot de contrôle. Cette dernière ne requièrant pas 
la connaissance de l'ordre d'exécution du programme, les AST sont tout-à-fait adaptés!

\begin{center}\input{ast.fig}\end{center}

\subsection{Graphe de flot de contrôle}
Un graphe de flot de contrôle est un graphe orienté dont les noeuds représentent une déclaration et les arcs un 
flot de contrôle. Chaque noeud est une unique opération de notre programme. Dans notre cas, le graphe de flot de 
contrôle aura un seul point d'entrée et un seul point de sortie. Ils sont considérés comme des noeuds ``sans opération''. 
De manière à construire ce graphe, on peut assigner à chaques déclarations procurant une unique exécution, un label. 
Dans notre cas, ces déclarations sont l'assignation, la condition ainsi que la boucle. En voici quelques exemples:

\begin{center}\input{cfg.fig}\end{center}

\subsection{Implémentation}
Détails sur l'implémentation.