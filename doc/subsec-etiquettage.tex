\subsection{Étiquettage}
Avant tout, introduisons la fonction suivante,

\[
	\lambda: Stm \longrightarrow \mathbb{N}
\]
\newline
qui prend une déclaration $s$ et retourne une suite d'étiquettes rencontrées à partir de $s$.
\newline
\newline
\definition{Soient $s \in Stm$ et $(l_n)_{n\in\mathbb{N}}=\lambda(s)$, $s$ est dite bien formée si et seulement}
si $\forall i \in \mathbb{N}, \forall j \in \mathbb{N}$ tel que $i \ne j$ alors $l_i \ne l_j$.
\newline
\newline
Étant donné un programme $P$ défini par l'ensemble de ses déclarations atomiques, on a alors que 
$\pi \in \mathcal{P}(P)$, un sous bloc de ce programme, n'admet qu'une seule entrée et une ou plusieurs sorties. 
On peut maintenant définir la fonction $\iota$, qui retournera la première étiquette rencontrée dans une déclaration,

\begin{align*}
	\iota : Stm &\longrightarrow \mathbb{N}\\
	(\sassign{Id}{Exp_a})^l &\longmapsto l\\
	\sseq{s_1}{s_2} &\longmapsto \iota(s_1)\\
	{\sskip}^l &\longmapsto l\\
	\ifthenelse{b^l}{s_1}{s_2} &\longmapsto l\\
	\whiledo{b^l}{s} &\longmapsto l
\end{align*}
Comme expliqué précédemment, il est aussi nécessaire de déclarer une fonction $\phi$ qui retournera l'ensemble des étiquettes finales 
à la fin d'un bloc $\pi$.

\begin{align*}
	\phi : Stm &\longrightarrow \mathcal{P}(\mathbb{N})\\
	(\sassign{Id}{Exp_a})^l &\longmapsto \{l\}\\
	\sseq{s_1}{s_2} &\longmapsto \phi(s_2)\\
	\sskip^l &\longmapsto \{l\}\\
	\ifthenelse{b^l}{s_1}{s_2} &\longmapsto \phi(s_1) \cup \phi(s_2)\\
	\whiledo{b^l}{s} &\longmapsto \{l\}
\end{align*}