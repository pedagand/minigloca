\subsection{Sémantique}
Maintenant que nous avons correctement défini l'interpréteur, il est possible 
de construire la sémantique du langage. Il est ensuite possible de développer 
un ensemble de règles logiques. La syntaxe de la déclaration des règles,
prenant en compte nos état et déclaration, sera donc de la forme suivante,

\[Stm, \mathcal{S} \longrightarrow Stm', \mathcal{S}'\]
\\
où $Stm$ est la première déclaration, $Stm'$ celle qui suit après son exécution, 
$\mathcal{S}$ l'état initial et $\mathcal{S}'$  l'état successeur. Commençons 
par la déclaration vide,

\srule{ }{\semanticd{\sskip}{\sigma}{\emptyset}{\sigma}}

Poursuivons avec la déclaration de l'assignation,
\srule{ }{\semanticd{\sassign{Id}{a}}{\sigma}{\emptyset}{\sigma'[Id\longmapsto\intr{a}{A}{\sigma}]}}
Ici, le nouvel état $\sigma'$ lie l'identifiant de la variable assignée, à la 
valeur de l'expression arithmétique $\intrfun{a}{A}$. Poursuivons avec la règle 
de la séquence entre deux déclarations, d'une part si la première termine,
\srule{\semanticd{Stm_1}{\sigma}{\emptyset}{\sigma'}}
{\semanticd{\sseq{Stm_1}{Stm_2}}{\sigma}{Stm_2}{\sigma'}}
D'autre part, si la première ne termine pas,
\srule{\semanticd{Stm_1}{\sigma}{Stm_1'}{\sigma'}}
{\semanticd{\sseq{Stm_1}{Stm_2}}{\sigma}{\sseq{Stm_1'}{Stm_2}}{\sigma'}}
La condition peut se formaliser de la sorte dans le cas où la garde est vérifiée,
\srule{\intr{b}{B}{\sigma}}
{\semanticd{\ifthenelse{b}{Stm_1}{Stm_2}}{\sigma}{Stm_1}{\sigma}}
Dans le cas où elle ne l'est pas,
\srule{\neg\intr{b}{B}{\sigma}}
{\semanticd{\ifthenelse{b}{Stm_1}{Stm_2}}{\sigma}{Stm_2}{\sigma}}
La dernière de nos déclarations est la boucle while, celle-ci peut en fait être 
décrite grâce à la déclaration de la condition de la manière suivante,
\[
\whiledo{b}{Stm}
\equiv_d
\ifthenelse{b}{\whiledo{b}{Stm}}{\sskip}
\]
Ainsi, on peut déclarer la règle qui suit pour la déclaration while,
\srule{\intr{b}{B}{\sigma}}
{\semanticd{\whiledo{b}{Stm}}{\sigma}{\sseq{Stm}{\whiledo{b}{Stm}}}{\sigma}}