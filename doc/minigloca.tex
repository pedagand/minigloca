\documentclass[a4paper, 12pt]{article}

\usepackage[francais]{babel}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{tikz}
\usepackage{mathpartir}
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
	language=caml,
	columns=[c]fixed,
	basicstyle=\small\ttfamily,
	keywordstyle=\bfseries,
	upquote=true,
	commentstyle=,
	breaklines=true,
	showstringspaces=false,
	stringstyle=\color{green},
	literate={'"'}{\textquotesingle "\textquotesingle}3
}

\title{Minigloca}
\author{Vladislas de Haldat}

\begin{document}

\maketitle
\newpage
\tableofcontents
\newpage

\section{Un langage impératif simple}
Pour commencer, définissons une syntaxe abstraite minimale que nous utiliserons tout le long de cette étude. 
Cette syntaxe se composera de trois blocs fondamentaux que sont les expressions arithmétiques, les expressions 
booléennes ainsi que les déclarations. Nous n'incluons pas pour le moment la déclaration de routines au sein de cette syntaxe.

\subsection{Expressions arithmétiques}
Les expressions arithmétiques sont définies sur l'ensemble des entiers relatifs. On se donne les opérateurs 
de l'addition, de la soustraction ainsi que de la multiplication. À ces opérateurs l'on pourra appliquer des 
entiers ainsi que des identifiants de variables.

\begin{align*}
Int &\rightarrow n &n \in \mathbb{Z}\\
Id &\rightarrow x \mid y \mid z \mid \cdots \\
Exp_a &\rightarrow Int \mid Id \mid op_A(a_1, a_2) &op_A \in \{+, -, \times\}
\end{align*}

L'identifiant d'une variable est, de manière générale, une chaîne de caractères.

\subsection{Expressions booléennes}
Les expressions booléennes nous permettent d'introduire la comparaison entre deux expressions arithmétiques, 
ainsi que les opérateurs booléens sur les expressions booléennes.

\begin{align*}
Exp_b & \rightarrow \textbf{true} \mid \textbf{false} & \\
  & \mid op_R(a_1, a_2) & op_R \in \{<, =\} \\
  & \mid op_B(b_1, b_2) & op_B \in \{\wedge, \vee\} \\
  & \mid \neg b &
\end{align*}

\subsection{Déclarations}
Les déclarations sont définies de la manière suivante:

\begin{align*}
Stm & \rightarrow Id := Exp_a \\
  & \mid s_1 \text{ ; } s_2 \\
  & \mid \\
  & \mid \text{if } b \text{ then } s_1 \text{ else } s_2 \\
  & \mid \text{while } b \text{ do } s_1
\end{align*}

\subsection{Exemple}
Voici un premier exemple sur ce langage
\begin{lstlisting}
a := 1;
b := 20;

if a = 3 then
	c := 4
else
	c := 6
endif;

while b < 100 do
	b := b + 1
done
\end{lstlisting}

\subsection{Arbre de syntaxe abstraite}
Ce modèle de représentation permet de construire un arbre de syntaxe abstraite (AST) du programme en question, 
cette structure étant un moyen pratique de le représenter. Cela nous servira particulièrement lors des différentes 
analyses qui seront effectuées, et notamment l'analyse par flot de contrôle. Cette dernière ne requièrant pas 
la connaissance de l'ordre d'exécution du programme, les AST sont tout-à-fait adaptés !

\tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        

\begin{tikzpicture}[x=0.65pt,y=0.65pt,yscale=-1,xscale=1]
%uncomment if require: \path (0,300); %set diagram left start at 0, and has height of 300

%Rounded Rect [id:dp316099536631091] 
\draw  [color={rgb, 255:red, 0; green, 0; blue, 0 }  ,draw opacity=1 ] (216,16) .. controls (216,11.58) and (219.58,8) .. (224,8) -- (278,8) .. controls (282.42,8) and (286,11.58) .. (286,16) -- (286,40) .. controls (286,44.42) and (282.42,48) .. (278,48) -- (224,48) .. controls (219.58,48) and (216,44.42) .. (216,40) -- cycle ;
%Rounded Rect [id:dp33840872904179997] 
\draw   (119,66.6) .. controls (119,62.4) and (122.4,59) .. (126.6,59) -- (149.4,59) .. controls (153.6,59) and (157,62.4) .. (157,66.6) -- (157,91.4) .. controls (157,95.6) and (153.6,99) .. (149.4,99) -- (126.6,99) .. controls (122.4,99) and (119,95.6) .. (119,91.4) -- cycle ;
%Rounded Rect [id:dp8407643396316534] 
\draw   (59,137.8) .. controls (59,133.49) and (62.49,130) .. (66.8,130) -- (90.2,130) .. controls (94.51,130) and (98,133.49) .. (98,137.8) -- (98,162.2) .. controls (98,166.51) and (94.51,170) .. (90.2,170) -- (66.8,170) .. controls (62.49,170) and (59,166.51) .. (59,162.2) -- cycle ;
%Rounded Rect [id:dp3057450403089408] 
\draw   (178,135.8) .. controls (178,131.49) and (181.49,128) .. (185.8,128) -- (209.2,128) .. controls (213.51,128) and (217,131.49) .. (217,135.8) -- (217,160.2) .. controls (217,164.51) and (213.51,168) .. (209.2,168) -- (185.8,168) .. controls (181.49,168) and (178,164.51) .. (178,160.2) -- cycle ;
%Curve Lines [id:da6141446784908873] 
\draw    (136,59.88) .. controls (176,29.88) and (184,78) .. (224,48) ;
%Straight Lines [id:da04833348399325699] 
\draw    (149.4,99) -- (185.8,128) ;
%Straight Lines [id:da9045199391799917] 
\draw    (126.6,99) -- (90.2,130) ;
%Rounded Rect [id:dp5748680612450809] 
\draw  [color={rgb, 255:red, 0; green, 0; blue, 0 }  ,draw opacity=1 ] (329,67) .. controls (329,62.58) and (332.58,59) .. (337,59) -- (408,59) .. controls (412.42,59) and (416,62.58) .. (416,67) -- (416,91) .. controls (416,95.42) and (412.42,99) .. (408,99) -- (337,99) .. controls (332.58,99) and (329,95.42) .. (329,91) -- cycle ;
%Rounded Rect [id:dp3612843880020622] 
\draw  [color={rgb, 255:red, 0; green, 0; blue, 0 }  ,draw opacity=1 ] (249,122) .. controls (249,117.58) and (252.58,114) .. (257,114) -- (300,114) .. controls (304.42,114) and (308,117.58) .. (308,122) -- (308,146) .. controls (308,150.42) and (304.42,154) .. (300,154) -- (257,154) .. controls (252.58,154) and (249,150.42) .. (249,146) -- cycle ;
%Rounded Rect [id:dp055644544678203456] 
\draw   (442,122.6) .. controls (442,118.4) and (445.4,115) .. (449.6,115) -- (472.4,115) .. controls (476.6,115) and (480,118.4) .. (480,122.6) -- (480,147.4) .. controls (480,151.6) and (476.6,155) .. (472.4,155) -- (449.6,155) .. controls (445.4,155) and (442,151.6) .. (442,147.4) -- cycle ;
%Rounded Rect [id:dp6683035003775551] 
\draw   (382,193.8) .. controls (382,189.49) and (385.49,186) .. (389.8,186) -- (413.2,186) .. controls (417.51,186) and (421,189.49) .. (421,193.8) -- (421,218.2) .. controls (421,222.51) and (417.51,226) .. (413.2,226) -- (389.8,226) .. controls (385.49,226) and (382,222.51) .. (382,218.2) -- cycle ;
%Rounded Rect [id:dp8914696877419822] 
\draw   (501,191.8) .. controls (501,187.49) and (504.49,184) .. (508.8,184) -- (532.2,184) .. controls (536.51,184) and (540,187.49) .. (540,191.8) -- (540,216.2) .. controls (540,220.51) and (536.51,224) .. (532.2,224) -- (508.8,224) .. controls (504.49,224) and (501,220.51) .. (501,216.2) -- cycle ;
%Straight Lines [id:da8882307352223866] 
\draw    (472.4,155) -- (508.8,184) ;
%Straight Lines [id:da9790620864250305] 
\draw    (449.6,155) -- (413.2,186) ;
%Straight Lines [id:da12118086140717765] 
\draw    (329,91) -- (300,114) ;
%Straight Lines [id:da39768277679043196] 
\draw    (416,91) -- (445,117.88) ;
%Rounded Rect [id:dp8599878129427122] 
\draw   (443,261.8) .. controls (443,257.49) and (446.49,254) .. (450.8,254) -- (474.2,254) .. controls (478.51,254) and (482,257.49) .. (482,261.8) -- (482,286.2) .. controls (482,290.51) and (478.51,294) .. (474.2,294) -- (450.8,294) .. controls (446.49,294) and (443,290.51) .. (443,286.2) -- cycle ;
%Rounded Rect [id:dp9180203887589913] 
\draw   (562,259.8) .. controls (562,255.49) and (565.49,252) .. (569.8,252) -- (593.2,252) .. controls (597.51,252) and (601,255.49) .. (601,259.8) -- (601,284.2) .. controls (601,288.51) and (597.51,292) .. (593.2,292) -- (569.8,292) .. controls (565.49,292) and (562,288.51) .. (562,284.2) -- cycle ;
%Straight Lines [id:da7036100051332425] 
\draw    (533.4,223) -- (569.8,252) ;
%Straight Lines [id:da23434667048727742] 
\draw    (510.6,223) -- (474.2,254) ;
%Curve Lines [id:da5360067013313288] 
\draw    (278,48) .. controls (309,57.88) and (341,45.88) .. (372,59.88) ;

% Text Node
\draw (233,19) node [anchor=north west][inner sep=0.5pt]   [align=left] {SEQ};
% Text Node
\draw (129,72) node [anchor=north west][inner sep=0.5pt]   [align=left] {$:=$};
% Text Node
\draw (74,144) node [anchor=north west][inner sep=0.5pt]   [align=left] {$a$};
% Text Node
\draw (192,139) node [anchor=north west][inner sep=0.75pt]   [align=left] {$2$};
% Text Node
\draw (343,70) node [anchor=north west][inner sep=0.75pt]   [align=left] {whiledo};
% Text Node
\draw (255,125) node [anchor=north west][inner sep=0.5pt]   [align=left] {$a < 5$};
% Text Node
\draw (454,127) node [anchor=north west][inner sep=0.75pt]   [align=left] {$:=$};
% Text Node
\draw (397,199) node [anchor=north west][inner sep=0.75pt]   [align=left] {$a$};
% Text Node
\draw (515,195) node [anchor=north west][inner sep=0.75pt]   [align=left] {$+$};
% Text Node
\draw (458,268) node [anchor=north west][inner sep=0.75pt]   [align=left] {$a$};
% Text Node
\draw (576,263) node [anchor=north west][inner sep=0.75pt]   [align=left] {$1$};

\end{tikzpicture}

\subsection{Graphe de flot de contrôle}
Un graphe de flot de contrôle est un graphe orienté dont les noeuds représentent une déclaration et les arcs un 
flot de contrôle. Chaque noeud est une unique opération de notre programme. Dans notre cas, le graphe de flot de 
contrôle aura un seul point d'entrée et un seul point de sortie. Ils sont considérés comme des noeuds "sans opération". 
De manière à construire ce graphe, on peut assigner à chaques déclarations procurant une unique exécution, un label. 
Dans notre cas, ces déclarations sont l'assignation, la condition ainsi que la boucle. En voici quelques exemples:

\begin{center}
\begin{tikzpicture}[x=0.5pt,y=0.5pt,yscale=-1,xscale=1]
%uncomment if require: \path (0,425); %set diagram left start at 0, and has height of 425

%Shape: Circle [id:dp8889259145087691] 
\draw   (107,44.75) .. controls (107,40.19) and (110.69,36.5) .. (115.25,36.5) .. controls (119.81,36.5) and (123.5,40.19) .. (123.5,44.75) .. controls (123.5,49.31) and (119.81,53) .. (115.25,53) .. controls (110.69,53) and (107,49.31) .. (107,44.75) -- cycle ;
%Straight Lines [id:da772227538499386] 
\draw    (115,53) -- (114.76,102.5) ;
\draw [shift={(114.75,104.5)}, rotate = 270.28] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Rounded Rect [id:dp5398833245483953] 
\draw   (86,112.9) .. controls (86,109.09) and (89.09,106) .. (92.9,106) -- (137.1,106) .. controls (140.91,106) and (144,109.09) .. (144,112.9) -- (144,133.6) .. controls (144,137.41) and (140.91,140.5) .. (137.1,140.5) -- (92.9,140.5) .. controls (89.09,140.5) and (86,137.41) .. (86,133.6) -- cycle ;
%Shape: Circle [id:dp3457167794238666] 
\draw   (106.5,199.75) .. controls (106.5,195.19) and (110.19,191.5) .. (114.75,191.5) .. controls (119.31,191.5) and (123,195.19) .. (123,199.75) .. controls (123,204.31) and (119.31,208) .. (114.75,208) .. controls (110.19,208) and (106.5,204.31) .. (106.5,199.75) -- cycle ;
%Straight Lines [id:da7369132824559896] 
\draw    (115,140) -- (114.76,189.5) ;
\draw [shift={(114.75,191.5)}, rotate = 270.28] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Shape: Circle [id:dp7355483344397601] 
\draw   (206,44.75) .. controls (206,40.19) and (209.69,36.5) .. (214.25,36.5) .. controls (218.81,36.5) and (222.5,40.19) .. (222.5,44.75) .. controls (222.5,49.31) and (218.81,53) .. (214.25,53) .. controls (209.69,53) and (206,49.31) .. (206,44.75) -- cycle ;
%Straight Lines [id:da9660007638995571] 
\draw    (214,53) -- (213.76,102.5) ;
\draw [shift={(213.75,104.5)}, rotate = 270.28] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Rounded Rect [id:dp5939480669313789] 
\draw   (185,112.9) .. controls (185,109.09) and (188.09,106) .. (191.9,106) -- (236.1,106) .. controls (239.91,106) and (243,109.09) .. (243,112.9) -- (243,133.6) .. controls (243,137.41) and (239.91,140.5) .. (236.1,140.5) -- (191.9,140.5) .. controls (188.09,140.5) and (185,137.41) .. (185,133.6) -- cycle ;
%Shape: Circle [id:dp8308347075176131] 
\draw   (206.5,374.75) .. controls (206.5,370.19) and (210.19,366.5) .. (214.75,366.5) .. controls (219.31,366.5) and (223,370.19) .. (223,374.75) .. controls (223,379.31) and (219.31,383) .. (214.75,383) .. controls (210.19,383) and (206.5,379.31) .. (206.5,374.75) -- cycle ;
%Straight Lines [id:da7419941554714581] 
\draw    (214,140) -- (213.76,189.5) ;
\draw [shift={(213.75,191.5)}, rotate = 270.28] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da5396028453836075] 
\draw    (246,122) -- (294,122.48) ;
\draw [shift={(296,122.5)}, rotate = 180.57] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Rounded Rect [id:dp9779259029982671] 
\draw   (297,112.9) .. controls (297,109.09) and (300.09,106) .. (303.9,106) -- (348.1,106) .. controls (351.91,106) and (355,109.09) .. (355,112.9) -- (355,133.6) .. controls (355,137.41) and (351.91,140.5) .. (348.1,140.5) -- (303.9,140.5) .. controls (300.09,140.5) and (297,137.41) .. (297,133.6) -- cycle ;
%Rounded Rect [id:dp8086406643905454] 
\draw   (186,198.9) .. controls (186,195.09) and (189.09,192) .. (192.9,192) -- (237.1,192) .. controls (240.91,192) and (244,195.09) .. (244,198.9) -- (244,219.6) .. controls (244,223.41) and (240.91,226.5) .. (237.1,226.5) -- (192.9,226.5) .. controls (189.09,226.5) and (186,223.41) .. (186,219.6) -- cycle ;
%Rounded Rect [id:dp38046926772453826] 
\draw   (185,286.9) .. controls (185,283.09) and (188.09,280) .. (191.9,280) -- (236.1,280) .. controls (239.91,280) and (243,283.09) .. (243,286.9) -- (243,307.6) .. controls (243,311.41) and (239.91,314.5) .. (236.1,314.5) -- (191.9,314.5) .. controls (188.09,314.5) and (185,311.41) .. (185,307.6) -- cycle ;
%Straight Lines [id:da343057386941517] 
\draw    (214,226) -- (213.76,275.5) ;
\draw [shift={(213.75,277.5)}, rotate = 270.28] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da7845861921686959] 
\draw    (215,315) -- (214.76,364.5) ;
\draw [shift={(214.75,366.5)}, rotate = 270.28] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Curve Lines [id:da7360022461189384] 
\draw    (329,140.5) .. controls (328.01,241) and (336.91,296.94) .. (245.39,296.51) ;
\draw [shift={(244,296.5)}, rotate = 0.62] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;

% Text Node
\draw (105,112) node [anchor=north west][inner sep=0.75pt]   [align=left] {$l_1$};
% Text Node
\draw (203,112) node [anchor=north west][inner sep=0.75pt]   [align=left] {$l_1$};
% Text Node
\draw (315,112) node [anchor=north west][inner sep=0.75pt]   [align=left] {$l_2$};
% Text Node
\draw (204,198) node [anchor=north west][inner sep=0.75pt]   [align=left] {$l_3$};
% Text Node
\draw (203,286) node [anchor=north west][inner sep=0.75pt]   [align=left] {$l_4$};

\end{tikzpicture}
\end{center}

\subsection{Implémentation}
Détails sur l'implémentation.

\section{Interpréteur et sémantique}
Dans ce chapitre, on s'atèle à décrire l'interpréteur ainsi que la sémantique sur notre petit langage impératif. 
Dans ce cadre là, on définit l'état du programme par une bijection entre l'identifiant des variables et leur valeur, 
ici un entier:
$$\sigma : \mathbb{V} \longrightarrow \mathbb{Z}$$
On introduire aussi la bijection $\mu_B$,
$$\mu_B : \mathcal{B} \longrightarrow \mathbb{B}$$
où $\mathcal{B} = \{\textbf{true}$, \textbf{false}\} les valeurs booléennes de notre langage et $\mathbb{B} = \{\top, \bot\}$ 
l'ensemble des valeurs booléennes natives à OCaml. Pour la suite, on considèrera l'ensemble des états $\mathcal{S} = \mathbb{Z}^\mathbb{V}$.
Les états décriront l'évolution de l'exécution du programme.
\subsection{Interpréteur}
Sur les expressions arithmétiques, définies dans le chapitre 1, on se donne la fonction suivante:
\begin{align*}
	[\![Exp_a]\!]^A : \mathcal{S} &\longrightarrow \mathbb{Z}\\
	[\![Id]\!]^A : \sigma &\longmapsto \sigma(Id)\\
	[\![a_1+a_2]\!]^A : \sigma &\longmapsto [\![a_1]\!]^A(\sigma)\text{ }\hat{+}\text{ }[\![a_2]\!]^A(\sigma)\\
\end{align*}
Cette dernière est aussi définie respectivement aux autres opérateurs arithmétiques, introduit dans le chapitre précédent.
De la même manière, on définit la fonction qui suit sur les expressions booléennes:
\begin{align*}
	[\![Exp_b]\!]^{B} : \mathcal{S} &\longrightarrow \mathbb{B}\\	
	[\![b]\!]^{B} : \sigma &\longmapsto \mu(b)\\
	[\![a_1 = a_2]\!]^B : \sigma &\longmapsto [\![a_1]\!]^{A}(\sigma)\text{ }\hat{=}\text{ }[\![a_2]\!]^A(\sigma)\\
	[\![b_1 \wedge b_2]\!]^B : \sigma &\longmapsto [\![b_1]\!]^B(\sigma)\text{ }\hat{\wedge}\text{ }[\![b_2]\!]^B(\sigma)\\
	[\![\neg b]\!]^B : \sigma &\longmapsto \hat{\neg}[\![b]\!]^B(\sigma)
\end{align*}
Les opérateurs de la forme $\hat{op}$ représentent les opérateurs natifs à OCaml.

\subsection{Sémantique}
Maintenant que nous avons correctement défini l'interpréteur, il est possible de construire la sémantique du langage.
La logique de Hoare est un modèle formel qui nous permet la correction rigoureuse de nos programmes. Soient $P, Q$ des 
prédicats et $C$ une déclaration. Alors le triplet de Hoare est défini comme tel,

$$\{P\}C\{Q\}$$
Il est ensuite possible de développer un ensemble de règles logiques. Pour des raisons de commodités, on adaptera légèrement 
la syntaxe de la déclaration des règles, en prenant en compte nos état et déclaration, cela prendra donc la forme suivante,

$$Stm, \mathcal{S} \longrightarrow Stm', \mathcal{S}'$$
\\
où $Stm$ est la première déclaration, $Stm$ celle qui suit après son exécution, $\mathcal{S}$ l'état initial et $\mathcal{S}'$ 
l'état successeur. Commençons par la déclaration vide.

\begin{mathpar}
	\inferrule*[]
	{ }
	{\textit{Skip}, \sigma_A \longrightarrow \emptyset, \sigma_A}
\end{mathpar}
Poursuivons avec la déclaration de l'assignation,
\begin{mathpar}
	\inferrule*[]
	{ }
	{Id:=a,\sigma_A \longrightarrow \emptyset, \sigma_A' : Id \longmapsto [\![a]\!]^A(\sigma_A)}
\end{mathpar}
Ici, le nouvel état $\sigma_A'$ lie l'identifiant de la variable assignée, à la valeur de l'expression arithmétique $[\![a]\!]^A$.
Poursuivons avec la règle de la séquence entre deux déclarations, d'une part si la première termine,
\begin{mathpar}
	\inferrule*[]
	{Stm_1,\sigma \longrightarrow \emptyset,\sigma'}
	{Stm_1;Stm_2,\sigma \longrightarrow Stm_2, \sigma'}
\end{mathpar}
D'autre part, si la première ne termine pas,
\begin{mathpar}
	\inferrule*[]
	{Stm_1,\sigma \longrightarrow Stm_1',\sigma'}
	{Stm_1;Stm_2,\sigma \longrightarrow Stm_1';Stm_2,\sigma'}
\end{mathpar}
La condition peut se formaliser de la sorte dans le cas où la garde est vérifiée,
\begin{mathpar}
	\inferrule*[]
	{[\![b]\!]^B(\sigma_B)}
	{\text{if }b\text{ then }Stm_1\text{ else }Stm_2, \sigma_B \longrightarrow Stm_1, \sigma_B}
\end{mathpar}
Dans le cas où elle ne l'est pas,
\begin{mathpar}
	\inferrule*[]
	{\neg[\![b]\!]^B(\sigma_B)}
	{\text{if }b\text{ then }Stm_1\text{ else }Stm_2, \sigma_B \longrightarrow Stm_2, \sigma_B}
\end{mathpar}
La dernière de nos déclarations est la boucle while, celle-ci peut en fait être décrite grâce à la déclaration de la condition de la manière suivante,
$$
\text{while } b \text{ do }Stm
\equiv_d
\text{if }b\text{ then }Stm\text{ while }b\text{ do }Stm\text{ else }\textit{Skip}
$$
Ainsi, on peut déclarer la règle qui suit pour la déclaration while,
\begin{mathpar}
	\inferrule*[]
	{[\![b]\!]^B(\sigma_B)}
	{\text{while }b\text{ do }Stm, \sigma_B \longrightarrow Stm\text{ ; while }b\text{ do }Stm,\sigma_B}
\end{mathpar}

\section{Prérequis à l'analyse}
De manière à pouvoir travailler avec les analyses de flot de données et de flot de contrôle, 
il nous est au préalable nécessaire d'approfondir le principe d'étiquettage déjà abordé à la fin du premier chapitre.

\subsection{Étiquettage}
Avant tout, introduisons la fonction suivante,

$$\lambda: Stm \longrightarrow (\mathbb{N})^\mathbb{N}$$\\
qui prend une déclaration $s$ et retourne une suite d'étiquettes rencontrées à partir de $s$.
\newline
\newline
\textit{\textbf{Définition --}} Soient $s \in Stm$ et $(l_n)_{n\in\mathbb{N}}=\lambda(s)$, $s$ est dite bien formée si et seulement 
si $\forall i \in \mathbb{N}, \forall j \in \mathbb{N}$ tel que $i \ne j$ alors $l_i \ne l_j$.
\newline
\newline
Étant donné un programme $P$ défini par l'ensemble de ses déclarations atomiques, on a alors que 
$\pi \in \mathcal{P}(P)$, un sous bloc de ce programme, n'admet qu'une seule entrée et une ou plusieurs sorties. 
On peut maintenant définir la fonction $\iota$, qui retournera la première étiquette rencontrée dans une déclaration,

\begin{align*}
	\iota : Stm &\longrightarrow \mathbb{N}\\
	(Id:=a)^l &\longmapsto l\\
	s_1 ; s_2 &\longmapsto \iota(s_1)\\
	\textit{Skip}^l &\longmapsto l\\
	(\text{if }b\text{ then }s_1\text{ else }s_2)^l &\longmapsto l\\
	(\text{while }b\text{ do }s)^l &\longmapsto l
\end{align*}
Comme expliqué précédemment, il est aussi nécessaire de déclarer une fonction $\phi$ qui retournera l'ensemble des étiquettes finales 
à la fin d'un bloc $\pi$.

\begin{align*}
	\phi : Stm &\longrightarrow \mathcal{P}(\mathbb{N})\\
	(Id:=a)^l &\longmapsto \{l\}\\
	s_1 ; s_2 &\longmapsto \phi(s_2)\\
	\textit{Skip}^l &\longmapsto \{l\}\\
	(\text{if }b\text{ then }s_1\text{ else }s_2)^l &\longmapsto \phi(s_1) \cup \phi(s_2)\\
	(\text{while }b\text{ do }s)^l &\longmapsto \{l\}
\end{align*}

\subsection{Blocs}
De manière à faciliter l'analyse d'un programme, il est utile de partitionner et de factoriser notre représentation du code. 
Les blocs ont été évoqués dans la partie précédente comme des sous-parties de l'ensemble des déclarations atomiques d'un programme. 
On peut désormais les définir de la sorte,

\begin{align*}
	Block &\rightarrow Id := Exp_a\\
	&\mid Exp_b\\
	&\mid \text{Skip}
\end{align*}
Maintenant les blocs correctement définis, il nous faut pouvoir les lier à une étiquette. Pour ce faire, on se donne $\beta$ définie par,

\begin{align*}
	\beta : Stm &\longrightarrow \mathcal{P}(\mathbb{N} \times Block)\\
	(Id:=Exp_a)^l &\longmapsto \{(l, Id := Exp_a)\}\\
	s_1 ; s_2 &\longmapsto \beta(s_1) \cup \beta(s_2)\\
	\textit{Skip}^l &\longmapsto \{(l, \textit{Skip})\}\\
	(\text{if } b \text{ then }s_1\text{ else }s_2)^l &\longmapsto \{(l, b)\}\cup \beta(s_1)\cup\beta(s_2)\\
	(\text{while }b\text{ do }s)^l &\longmapsto \{(l, b)\}\cup\beta(s)
\end{align*}
À partir de là, il est possible de formaliser les graphes orientés de flot. Les blocs en représentent les noeuds, et le passage 
vers le bloc suivant est représenté par un arc.

\subsection{Flots}
Nous avons désormais toutes les structures nécéssaires à la construction de notre graphe de flot. Pour le moment, il s'agira de 
le construire naïvement, l'on reviendra plus tard sur les optimisations possibles. Ainsi, une manière simple de représenter ce 
graphe est de considérer l'ensemble des couples des étiquettes de blocs qui indiqueront un arc du premier élément au second. 
Pour ce faire, considérons l'application suivante, 

\begin{align*}
	\varrho : Stm &\longrightarrow \mathcal{P}(\mathbb{N}^2) \\
	Id:=Exp_a &\longmapsto \emptyset \\
	\textit{Skip} &\longmapsto \emptyset \\
	s_1 ; s_2 &\longmapsto \varrho(s_1) \cup \varrho(s_2) \cup [\phi(s_1)\times\{\iota(s_2)\}] \\
	(\text{if }b\text{ then }s_1\text{ else }s_2)^l &\longmapsto \varrho(s_1)\cup\varrho(s_2)\cup(l, \iota(s_1))\cup(l, \iota(s_2)) \\
	(\text{while }b\text{ do }s)^l &\longmapsto \varrho(s)\cup(l,\iota(s))\cup[\phi(s)\times\{l\}]
\end{align*}

\end{document}
